# -*- coding: utf-8 -*-
"""TesteTarget

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_JfKm-DvRns-JKhdebTQkyqwyum2fJ3L

1) Observe o trecho de código abaixo: int INDICE = 13, SOMA = 0, K = 0;
Enquanto K < INDICE faça { K = K + 1; SOMA = SOMA + K; }
Imprimir(SOMA);
Ao final do processamento, qual será o valor da variável SOMA?
"""

I = 13
SOMA = 0
K = 0

while K < I:
    K = K + 1
    SOMA = SOMA + K
print(SOMA)

"""2) Dado a sequência de Fibonacci, onde se inicia por 0 e 1 e o próximo valor sempre será a soma dos 2 valores anteriores (exemplo: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34...), escreva um programa na linguagem que desejar onde, informado um número, ele calcule a sequência de Fibonacci e retorne uma mensagem avisando se o número informado pertence ou não a sequência.

IMPORTANTE: Esse número pode ser informado através de qualquer entrada de sua preferência ou pode ser previamente definido no código;
"""

def pertence_fibonacci(numero):
    # Os dois primeiros números da sequência de Fibonacci
    a, b = 0, 1
    # Lista para armazenar a sequência (opcional)
    fibonacci = [a, b]

    # Caso o número seja 0 ou 1, já está na sequência
    if numero == a or numero == b:
        return True

    # Calcula a sequência até que o próximo número seja maior ou igual ao número informado
    while b < numero:
        a, b = b, a + b
        fibonacci.append(b)

    # Verifica se o número está na sequência
    return b == numero

def main():
    try:
        # Solicita ao usuário que insira um número
        numero = int(input("Digite um número para verificar se pertence à sequência de Fibonacci: "))

        if numero < 0:
            print("Por favor, insira um número inteiro não negativo.")
            return

        # Chama a função para verificar a pertença
        if pertence_fibonacci(numero):
            print(f"O número {numero} pertence à sequência de Fibonacci.")
        else:
            print(f"O número {numero} NÃO pertence à sequência de Fibonacci.")
    except ValueError:
        print("Entrada inválida! Por favor, insira um número inteiro.")

if __name__ == "__main__":
    main()

"""3) Dado um vetor que guarda o valor de faturamento diário de uma distribuidora, faça um programa, na linguagem que desejar, que calcule e retorne:
• O menor valor de faturamento ocorrido em um dia do mês;
• O maior valor de faturamento ocorrido em um dia do mês;
• Número de dias no mês em que o valor de faturamento diário foi superior à média mensal.

IMPORTANTE:
a) Usar o json ou xml disponível como fonte dos dados do faturamento mensal;
b) Podem existir dias sem faturamento, como nos finais de semana e feriados. Estes dias devem ser ignorados no cálculo da média;
"""

import pandas as pd
import xml.etree.ElementTree as ET
import os

def ler_csv(caminho_arquivo):
    try:
        df = pd.read_csv(caminho_arquivo)
        return df
    except Exception as e:
        print(f"Erro ao ler o arquivo CSV: {e}")
        return None

def ler_json(caminho_arquivo):
    try:
        df = pd.read_json(caminho_arquivo)
        print("Dados lidos do JSON:")
        print(df.head())  # Exibe as primeiras linhas para verificar a estrutura
        return df
    except Exception as e:
        print(f"Erro ao ler o arquivo JSON: {e}")
        return None

def ler_xml(caminho_arquivo):
    try:
        tree = ET.parse(caminho_arquivo)
        root = tree.getroot()
        dados = []
        for dia in root.findall('dia'):
            data = dia.find('data').text
            valor = float(dia.find('valor').text)
            dados.append({'data': data, 'valor': valor})
        df = pd.DataFrame(dados)
        return df
    except Exception as e:
        print(f"Erro ao ler o arquivo XML: {e}")
        return None

def obter_dataframe(caminho_arquivo):
    _, extensao = os.path.splitext(caminho_arquivo)
    extensao = extensao.lower()

    if extensao == '.csv':
        return ler_csv(caminho_arquivo)
    elif extensao == '.json':
        return ler_json(caminho_arquivo)
    elif extensao == '.xml':
        return ler_xml(caminho_arquivo)
    else:
        print("Formato de arquivo não suportado. Por favor, use CSV, JSON ou XML.")
        return None

def calcular_faturamento(df):
    # Filtrar dias com faturamento maior que zero
    df_com_faturamento = df[df['valor'] > 0]

    if df_com_faturamento.empty:
        print("Não há dias com faturamento para calcular.")
        return

    menor_faturamento = df_com_faturamento['valor'].min()
    maior_faturamento = df_com_faturamento['valor'].max()
    media_faturamento = df_com_faturamento['valor'].mean()
    dias_acima_media = df_com_faturamento[df_com_faturamento['valor'] > media_faturamento].shape[0]

    print(f"Menor faturamento no mês: R$ {menor_faturamento:.2f}")
    print(f"Maior faturamento no mês: R$ {maior_faturamento:.2f}")
    print(f"Número de dias com faturamento acima da média mensal (R$ {media_faturamento:.2f}): {dias_acima_media}")

def main():
    print("=== Análise de Faturamento Mensal ===")
    caminho_arquivo = input("Digite o caminho completo do arquivo de faturamento (CSV, JSON, XML): ").strip()

    if not os.path.isfile(caminho_arquivo):
        print("Arquivo não encontrado. Por favor, verifique o caminho e tente novamente.")
        return

    df = obter_dataframe(caminho_arquivo)

    if df is None:
        print("Erro ao processar o arquivo. Certifique-se de que o formato está correto.")
        return

    # Verificar se as colunas necessárias existem
    print("Colunas disponíveis no DataFrame:", df.columns.tolist())  # Depuração
    if not {'dia', 'valor'}.issubset(df.columns):
        print("O arquivo deve conter as colunas 'dia' e 'valor'.")
        return

    # Converter a coluna 'valor' para numérico, se necessário
    df['valor'] = pd.to_numeric(df['valor'], errors='coerce')

    # Remover linhas com valores NaN na coluna 'valor'
    df = df.dropna(subset=['valor'])

    calcular_faturamento(df)

if __name__ == "__main__":
    main()

"""4) Dado o valor de faturamento mensal de uma distribuidora, detalhado por estado:

• SP – R$67.836,43

• RJ – R$36.678,66

• MG – R$29.229,88

• ES – R$27.165,48

• Outros – R$19.849,53

Escreva um programa na linguagem que desejar onde calcule o percentual de representação que cada estado teve dentro do valor total mensal da distribuidora.
"""

# Define o faturamento por estado
faturamento = {
    'SP': 67836.43,    # São Paulo
    'RJ': 36678.66,    # Rio de Janeiro
    'MG': 29229.88,    # Minas Gerais
    'ES': 27165.48,    # Espírito Santo
    'Outros': 19849.53  # Outros estados
}

# Calcula o faturamento total somando todos os valores
faturamento_total = sum(faturamento.values())

# Inicializa um dicionário para armazenar os percentuais
percentuais = {}

# Itera sobre cada estado e seu faturamento para calcular o percentual
for estado, valor in faturamento.items():
    percentual = (valor / faturamento_total) * 100  # Calcula o percentual
    percentuais[estado] = percentual              # Armazena no dicionário

# Exibe os resultados de forma formatada
print("Percentual de representação por estado no faturamento mensal:")
print("-" * 60)  # Linha separadora
for estado, percentual in percentuais.items():
    print(f"{estado}: {percentual:.2f}%")  # Imprime o estado e seu percentual
print("-" * 60)  # Linha separadora
print(f"Faturamento Total: R$ {faturamento_total:,.2f}")  # Imprime o faturamento total

def inverter_string_iterativo(string_original):
    string_invertida = ""  # Inicializa a string invertida vazia
    comprimento = len(string_original)

    # Itera do último caractere até o primeiro
    for i in range(comprimento - 1, -1, -1):
        string_invertida += string_original[i]

    return string_invertida

def main():
    # Opção 1: Entrada do usuário
    string = input("Digite a string que deseja inverter: ")

    # Opção 2: String pré-definida (descomente a linha abaixo para usar)
    # string = "Exemplo de String"

    resultado = inverter_string_iterativo(string)
    print(f"String invertida: {resultado}")

if __name__ == "__main__":
    main()

